<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>python on Bartosz Zieliński</title>
    <link>https://bartoszpzielinski.github.io/tags/python/</link>
    <description>Recent content in python on Bartosz Zieliński</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 09 Mar 2023 11:06:44 +0100</lastBuildDate><atom:link href="https://bartoszpzielinski.github.io/tags/python/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Readers-Writers Problem</title>
      <link>https://bartoszpzielinski.github.io/posts/readers-writers/</link>
      <pubDate>Thu, 09 Mar 2023 11:06:44 +0100</pubDate>
      
      <guid>https://bartoszpzielinski.github.io/posts/readers-writers/</guid>
      <description>Consider reading previous posts about threads in python and locks and previous post about condition variables for a necessary background if you are not familiar with python threading and concurrency control.
Introduction The readers-writers problem is one of the classic synchronization problems in concurrency (together with mutual exclusion and the producer-consumer problem) that every computer scientist should know about. We start with the following observation: Operations on shared data should be done within critical sections, to exclude the possibility of two threads modifying the data simultaneously.</description>
    </item>
    
    <item>
      <title>Condition Variables, Part II</title>
      <link>https://bartoszpzielinski.github.io/posts/condition-variables-ii/</link>
      <pubDate>Mon, 06 Mar 2023 19:57:01 +0100</pubDate>
      
      <guid>https://bartoszpzielinski.github.io/posts/condition-variables-ii/</guid>
      <description>In a previous post about condition variables we introduced condition variables in Python, and we have shown how can they be used to solve producer-consumer problem. In this post we will tackle the problem of synchronizing threads so that they all reach certain milestone in the code before proceeding further, i.e., we will show how to implement barriers using condtion variables. Before that, we introduce gates: very useful synchronization primitives, easily implementable using condition variables.</description>
    </item>
    
    <item>
      <title>Condition Variables, Part I</title>
      <link>https://bartoszpzielinski.github.io/posts/condition-variables/</link>
      <pubDate>Thu, 02 Mar 2023 15:08:47 +0100</pubDate>
      
      <guid>https://bartoszpzielinski.github.io/posts/condition-variables/</guid>
      <description>Introduction In a previous post about threads we introduced locks from threading module in Python. Locks are a specialized mechanism used to protect a critical section. More general synchronization patterns require the use of other mechanisms such as semaphores, or condition variables discussed here.
Condition variables are a synchronization mechanism used, as the name suggests, to suspend the operation of a thread until a certain condition (usually concerning shared data) is met.</description>
    </item>
    
    <item>
      <title>Threads in Python</title>
      <link>https://bartoszpzielinski.github.io/posts/python-threads/</link>
      <pubDate>Sat, 25 Feb 2023 09:59:29 +0100</pubDate>
      
      <guid>https://bartoszpzielinski.github.io/posts/python-threads/</guid>
      <description>Module threading in Python3 contains functions and objects supporting creation, usage and synchronization of threads. Importantly, this module is portable: scripts using threading should work the same way under Linux, Windows, Mac, and other operating systems.
One limitation of threading module (at least in the CPython implementation) is a global interpreter lock which must be acquired by any thread executing Python interpreter. This effectively makes it impossible for pure Python threads within the same process to execute concurrently on multiple processor cores.</description>
    </item>
    
  </channel>
</rss>
